# Generated by Django 3.2.25 on 2024-08-05 07:27
from decimal import Decimal

from babel.numbers import get_currency_precision
from django.db import migrations, transaction
from django.db.models import Exists, OuterRef, Sum

# The batch of size 100 takes ~0.2 second and consumes 6.5MB memory
ORDER_SET_SUBTOTAL_PRICE_FOR_ORDER_FROM_BULK = 100


def quantize_price(price, currency):
    precision = get_currency_precision(currency)
    number_places = Decimal(10) ** -precision
    return price.quantize(number_places)


def update_order_authorize_status(order, granted_refund_amount):
    """Update the current authorize status for the order.

    The order is fully authorized when total_authorized or total_charged funds
    cover the order.total - order granted refunds
    The order is partially authorized when total_authorized or total_charged
    funds cover only part of the order.total - order granted refunds
    The order is not authorized when total_authorized and total_charged funds are 0.
    """
    total_covered = (
        order.total_authorized_amount + order.total_charged_amount
    ) or Decimal(0)
    total_covered = quantize_price(total_covered, order.currency)
    current_total_gross = order.total_gross_amount - granted_refund_amount
    current_total_gross = max(current_total_gross, Decimal(0))
    current_total_gross = quantize_price(current_total_gross, order.currency)

    if total_covered == Decimal(0) and order.total.gross.amount == Decimal(0):
        order.authorize_status = "full"
    elif total_covered == Decimal(0):
        order.authorize_status = "none"
    elif total_covered >= current_total_gross:
        order.authorize_status = "full"
    else:
        order.authorize_status = "partial"


def update_order_charge_status(order, granted_refund_amount):
    """Update the current charge status for the order.

    We treat the order as overcharged when the charged amount is bigger that
    order.total - order granted refund
    We treat the order as fully charged when the charged amount is equal to
    order.total - order granted refund.
    We treat the order as partially charged when the charged amount covers only part of
    the order.total - order granted refund
    We treat the order as not charged when the charged amount is 0.
    """
    total_charged = order.total_charged_amount or Decimal(0)
    total_charged = quantize_price(total_charged, order.currency)

    current_total_gross = order.total_gross_amount - granted_refund_amount
    current_total_gross = max(current_total_gross, Decimal(0))
    current_total_gross = quantize_price(current_total_gross, order.currency)

    if total_charged == current_total_gross:
        order.charge_status = "full"
    elif total_charged <= Decimal(0):
        order.charge_status = "none"
    elif total_charged < current_total_gross:
        order.charge_status = "partial"
    else:
        order.charge_status = "overcharged"


def _set_subtotal_for_orders_created_from_bulk(orders, order_model):
    order_ids = set()
    for order in orders:
        order.subtotal_net_amount = order.sum_line_total_price_net_amount
        order.subtotal_gross_amount = order.sum_line_total_price_gross_amount
        order.total_net_amount = (
            order.subtotal_net_amount + order.shipping_price_net_amount
        )
        order.total_gross_amount = (
            order.subtotal_gross_amount + order.shipping_price_gross_amount
        )

        # using order.shipping_price as this value is used for storing undiscounted
        # shipping price, received as mutation input or fetched from db.
        order.undiscounted_total_net_amount = (
            order.sum_line_undiscounted_total_price_net_amount
            + order.shipping_price_net_amount
        )
        order.undiscounted_total_gross_amount = (
            order.sum_line_undiscounted_total_price_gross_amount
            + order.shipping_price_gross_amount
        )
        update_order_authorize_status(
            order, granted_refund_amount=order.sum_granted_refunds or Decimal(0)
        )
        update_order_charge_status(
            order, granted_refund_amount=order.sum_granted_refunds or Decimal(0)
        )
        order_ids.add(order.id)

    with transaction.atomic():
        _orders = list(
            order_model.objects.filter(id__in=order_ids).select_for_update(
                of=(["self"])
            )
        )
        order_model.objects.bulk_update(
            orders,
            [
                "subtotal_net_amount",
                "subtotal_gross_amount",
                "total_net_amount",
                "total_gross_amount",
                "undiscounted_total_gross_amount",
                "undiscounted_total_net_amount",
                "charge_status",
                "authorize_status",
            ],
        )


def fix_order_subtotal_for_orders_from_bulk(apps, _schema_editor):
    Order = apps.get_model("order", "Order")
    OrderLine = apps.get_model("order", "OrderLine")

    order_lines_qs = OrderLine.objects.filter(total_price_gross_amount__gt=0).values(
        "order_id"
    )
    qs = Order.objects.filter(
        Exists(order_lines_qs.filter(order_id=OuterRef("id"))),
        origin="bulk_create",
        subtotal_gross_amount=Decimal(0),
    )
    for batch_numbers in queryset_in_batches(qs):
        orders = (
            Order.objects.prefetch_related(
                "payments", "payment_transactions", "granted_refunds"
            )
            .filter(number__in=batch_numbers)
            .annotate(
                sum_line_total_price_net_amount=Sum("lines__total_price_net_amount"),
                sum_line_total_price_gross_amount=Sum(
                    "lines__total_price_gross_amount"
                ),
                sum_line_undiscounted_total_price_net_amount=Sum(
                    "lines__undiscounted_total_price_net_amount"
                ),
                sum_line_undiscounted_total_price_gross_amount=Sum(
                    "lines__undiscounted_total_price_gross_amount"
                ),
                sum_granted_refunds=Sum("granted_refunds__amount_value"),
            )
        )
        _set_subtotal_for_orders_created_from_bulk(orders, order_model=Order)


def queryset_in_batches(queryset):
    """Slice a queryset into batches.

    Input queryset should be sorted be pk.
    """
    start_number = None

    while True:
        lookup = {}
        if start_number is not None:
            lookup["number__gt"] = start_number
        qs = queryset.order_by("number").filter(**lookup)[
            :ORDER_SET_SUBTOTAL_PRICE_FOR_ORDER_FROM_BULK
        ]
        numbers = list(qs.values_list("number", flat=True))

        if not numbers:
            break

        yield numbers

        start_number = numbers[-1]


class Migration(migrations.Migration):
    dependencies = [
        ("order", "0192_set_undiscounted_base_shipping_price_on_draft_orders"),
    ]

    operations = [
        migrations.RunPython(
            fix_order_subtotal_for_orders_from_bulk,
            reverse_code=migrations.RunPython.noop,
        )
    ]
